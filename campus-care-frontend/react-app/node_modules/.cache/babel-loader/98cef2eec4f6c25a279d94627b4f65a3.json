{"ast":null,"code":"import n from \"lodash/uniq\";\nimport t from \"lodash/uniqBy\";\nimport r from \"lodash/sortBy\";\nimport e from \"lodash/last\";\nimport a from \"lodash/isDate\";\nimport { utcParse as i, timeParse as o } from \"d3-time-format\";\nimport { scaleLinear as u, scalePoint as c, scaleBand as d, scaleUtc as f, scaleTime as s, scaleLog as l, scaleSymlog as m } from \"d3-scale\";\nimport { timeInterval as v, timeMillisecond as y, utcMillisecond as p, timeSecond as h, utcSecond as g, timeMinute as x, utcMinute as k, timeHour as T, utcHour as M, timeWeek as w, utcWeek as b, timeSunday as E, utcSunday as S, timeMonday as D, utcMonday as C, timeTuesday as U, utcTuesday as j, timeWednesday as O, utcWednesday as R, timeThursday as H, utcThursday as V, timeFriday as q, utcFriday as A, timeSaturday as B, utcSaturday as F, timeMonth as N, utcMonth as z, timeYear as I, utcYear as P } from \"d3-time\";\n\nfunction $() {\n  return $ = Object.assign || function (n) {\n    for (var t = 1; t < arguments.length; t++) {\n      var r = arguments[t];\n\n      for (var e in r) Object.prototype.hasOwnProperty.call(r, e) && (n[e] = r[e]);\n    }\n\n    return n;\n  }, $.apply(this, arguments);\n}\n\nvar G = [\"millisecond\", \"second\", \"minute\", \"hour\", \"day\", \"month\", \"year\"],\n    J = [function (n) {\n  return n.setMilliseconds(0);\n}, function (n) {\n  return n.setSeconds(0);\n}, function (n) {\n  return n.setMinutes(0);\n}, function (n) {\n  return n.setHours(0);\n}, function (n) {\n  return n.setDate(1);\n}, function (n) {\n  return n.setMonth(0);\n}],\n    K = {\n  millisecond: [],\n  second: J.slice(0, 1),\n  minute: J.slice(0, 2),\n  hour: J.slice(0, 3),\n  day: J.slice(0, 4),\n  month: J.slice(0, 5),\n  year: J.slice(0, 6)\n},\n    L = function (n) {\n  return function (t) {\n    return K[n].forEach(function (n) {\n      n(t);\n    }), t;\n  };\n},\n    Q = function (n) {\n  var t = n.format,\n      r = void 0 === t ? \"native\" : t,\n      e = n.precision,\n      a = void 0 === e ? \"millisecond\" : e,\n      u = n.useUTC,\n      c = void 0 === u || u,\n      d = L(a);\n  return function (n) {\n    if (void 0 === n) return n;\n    if (\"native\" === r || n instanceof Date) return d(n);\n    var t = c ? i(r) : o(r);\n    return d(t(n));\n  };\n},\n    W = function (n, t, r, e) {\n  var a,\n      i,\n      o,\n      c,\n      d = n.min,\n      f = void 0 === d ? 0 : d,\n      s = n.max,\n      l = void 0 === s ? \"auto\" : s,\n      m = n.stacked,\n      v = void 0 !== m && m,\n      y = n.reverse,\n      p = void 0 !== y && y,\n      h = n.clamp,\n      g = void 0 !== h && h,\n      x = n.nice,\n      k = void 0 !== x && x;\n  \"auto\" === f ? a = !0 === v ? null != (i = t.minStacked) ? i : 0 : t.min : a = f;\n  \"auto\" === l ? o = !0 === v ? null != (c = t.maxStacked) ? c : 0 : t.max : o = l;\n  var T = u().rangeRound(\"x\" === e ? [0, r] : [r, 0]).domain(p ? [o, a] : [a, o]).clamp(g);\n  return !0 === k ? T.nice() : \"number\" == typeof k && T.nice(k), X(T, v);\n},\n    X = function (n, t) {\n  void 0 === t && (t = !1);\n  var r = n;\n  return r.type = \"linear\", r.stacked = t, r;\n},\n    Y = function (n, t, r) {\n  var e = c().range([0, r]).domain(t.all);\n  return e.type = \"point\", e;\n},\n    Z = function (n, t, r, e) {\n  var a = n.round,\n      i = void 0 === a || a,\n      o = d().range(\"x\" === e ? [0, r] : [r, 0]).domain(t.all).round(i);\n  return _(o);\n},\n    _ = function (n) {\n  var t = n;\n  return t.type = \"band\", t;\n},\n    nn = function (n, t, r) {\n  var e,\n      a,\n      i = n.format,\n      o = void 0 === i ? \"native\" : i,\n      u = n.precision,\n      c = void 0 === u ? \"millisecond\" : u,\n      d = n.min,\n      l = void 0 === d ? \"auto\" : d,\n      m = n.max,\n      v = void 0 === m ? \"auto\" : m,\n      y = n.useUTC,\n      p = void 0 === y || y,\n      h = n.nice,\n      g = void 0 !== h && h,\n      x = Q({\n    format: o,\n    precision: c,\n    useUTC: p\n  });\n  e = \"auto\" === l ? x(t.min) : \"native\" !== o ? x(l) : l, a = \"auto\" === v ? x(t.max) : \"native\" !== o ? x(v) : v;\n  var k = p ? f() : s();\n  k.range([0, r]), e && a && k.domain([e, a]), !0 === g ? k.nice() : \"object\" != typeof g && \"number\" != typeof g || k.nice(g);\n  var T = k;\n  return T.type = \"time\", T.useUTC = p, T;\n},\n    tn = function (n, t, r, e) {\n  var a,\n      i = n.base,\n      o = void 0 === i ? 10 : i,\n      u = n.min,\n      c = void 0 === u ? \"auto\" : u,\n      d = n.max,\n      f = void 0 === d ? \"auto\" : d;\n  if (t.all.some(function (n) {\n    return 0 === n;\n  })) throw new Error(\"a log scale domain must not include or cross zero\");\n  var s,\n      m,\n      v = !1;\n  if (t.all.filter(function (n) {\n    return null != n;\n  }).forEach(function (n) {\n    v || (void 0 === a ? a = Math.sign(n) : Math.sign(n) !== a && (v = !0));\n  }), v) throw new Error(\"a log scale domain must be strictly-positive or strictly-negative\");\n  s = \"auto\" === c ? t.min : c, m = \"auto\" === f ? t.max : f;\n  var y = l().domain([s, m]).rangeRound(\"x\" === e ? [0, r] : [r, 0]).base(o).nice();\n  return y.type = \"log\", y;\n},\n    rn = function (n, t, r, e) {\n  var a,\n      i,\n      o = n.constant,\n      u = void 0 === o ? 1 : o,\n      c = n.min,\n      d = void 0 === c ? \"auto\" : c,\n      f = n.max,\n      s = void 0 === f ? \"auto\" : f,\n      l = n.reverse,\n      v = void 0 !== l && l;\n  a = \"auto\" === d ? t.min : d, i = \"auto\" === s ? t.max : s;\n  var y = m().constant(u).rangeRound(\"x\" === e ? [0, r] : [r, 0]).nice();\n  !0 === v ? y.domain([i, a]) : y.domain([a, i]);\n  var p = y;\n  return p.type = \"symlog\", p;\n},\n    en = function (n) {\n  return \"x\" === n ? \"y\" : \"x\";\n},\n    an = function (n, t) {\n  return n === t;\n},\n    on = function (n, t) {\n  return n.getTime() === t.getTime();\n};\n\nfunction un(n, t, r, e) {\n  switch (n.type) {\n    case \"linear\":\n      return W(n, t, r, e);\n\n    case \"point\":\n      return Y(0, t, r);\n\n    case \"band\":\n      return Z(n, t, r, e);\n\n    case \"time\":\n      return nn(n, t, r);\n\n    case \"log\":\n      return tn(n, t, r, e);\n\n    case \"symlog\":\n      return rn(n, t, r, e);\n\n    default:\n      throw new Error(\"invalid scale spec\");\n  }\n}\n\nvar cn = function (n, t, r) {\n  var e;\n\n  if (\"stacked\" in r && r.stacked) {\n    var a = n.data[\"x\" === t ? \"xStacked\" : \"yStacked\"];\n    return null == a ? null : r(a);\n  }\n\n  return null != (e = r(n.data[t])) ? e : null;\n},\n    dn = function (n, t, r, e, a) {\n  var i = n.map(function (n) {\n    return function (n) {\n      return $({}, n, {\n        data: n.data.map(function (n) {\n          return {\n            data: $({}, n)\n          };\n        })\n      });\n    }(n);\n  }),\n      o = fn(i, t, r);\n  \"stacked\" in t && !0 === t.stacked && mn(o, i), \"stacked\" in r && !0 === r.stacked && vn(o, i);\n  var u = un(t, o.x, e, \"x\"),\n      c = un(r, o.y, a, \"y\"),\n      d = i.map(function (n) {\n    return $({}, n, {\n      data: n.data.map(function (n) {\n        return $({}, n, {\n          position: {\n            x: cn(n, \"x\", u),\n            y: cn(n, \"y\", c)\n          }\n        });\n      })\n    });\n  });\n  return $({}, o, {\n    series: d,\n    xScale: u,\n    yScale: c\n  });\n},\n    fn = function (n, t, r) {\n  return {\n    x: sn(n, \"x\", t),\n    y: sn(n, \"y\", r)\n  };\n},\n    sn = function (a, i, o, u) {\n  var c = void 0 === u ? {} : u,\n      d = c.getValue,\n      f = void 0 === d ? function (n) {\n    return n.data[i];\n  } : d,\n      s = c.setValue,\n      l = void 0 === s ? function (n, t) {\n    n.data[i] = t;\n  } : s;\n  if (\"linear\" === o.type) a.forEach(function (n) {\n    n.data.forEach(function (n) {\n      var t = f(n);\n      t && l(n, parseFloat(String(t)));\n    });\n  });else if (\"time\" === o.type && \"native\" !== o.format) {\n    var m = Q(o);\n    a.forEach(function (n) {\n      n.data.forEach(function (n) {\n        var t = f(n);\n        t && l(n, m(t));\n      });\n    });\n  }\n  var v = [];\n\n  switch (a.forEach(function (n) {\n    n.data.forEach(function (n) {\n      v.push(f(n));\n    });\n  }), o.type) {\n    case \"linear\":\n      var y = r(n(v).filter(function (n) {\n        return null !== n;\n      }), function (n) {\n        return n;\n      });\n      return {\n        all: y,\n        min: Math.min.apply(Math, y),\n        max: Math.max.apply(Math, y)\n      };\n\n    case \"time\":\n      var p = t(v, function (n) {\n        return n.getTime();\n      }).slice(0).sort(function (n, t) {\n        return t.getTime() - n.getTime();\n      }).reverse();\n      return {\n        all: p,\n        min: p[0],\n        max: e(p)\n      };\n\n    default:\n      var h = n(v);\n      return {\n        all: h,\n        min: h[0],\n        max: e(h)\n      };\n  }\n},\n    ln = function (n, t, r) {\n  var i = en(n),\n      o = [];\n  t[i].all.forEach(function (t) {\n    var u = a(t) ? on : an,\n        c = [];\n    r.forEach(function (r) {\n      var a = r.data.find(function (n) {\n        return u(n.data[i], t);\n      }),\n          d = null,\n          f = null;\n\n      if (void 0 !== a) {\n        if (null !== (d = a.data[n])) {\n          var s = e(c);\n          void 0 === s ? f = d : null !== s && (f = s + d);\n        }\n\n        a.data[\"x\" === n ? \"xStacked\" : \"yStacked\"] = f;\n      }\n\n      c.push(f), null !== f && o.push(f);\n    });\n  }), t[n].minStacked = Math.min.apply(Math, o), t[n].maxStacked = Math.max.apply(Math, o);\n},\n    mn = function (n, t) {\n  return ln(\"x\", n, t);\n},\n    vn = function (n, t) {\n  return ln(\"y\", n, t);\n},\n    yn = function (n) {\n  var t = n.bandwidth();\n  if (0 === t) return n;\n  var r = t / 2;\n  return n.round() && (r = Math.round(r)), function (t) {\n    var e;\n    return (null != (e = n(t)) ? e : 0) + r;\n  };\n},\n    pn = {\n  millisecond: [y, p],\n  second: [h, g],\n  minute: [x, k],\n  hour: [T, M],\n  day: [v(function (n) {\n    return n.setHours(0, 0, 0, 0);\n  }, function (n, t) {\n    return n.setDate(n.getDate() + t);\n  }, function (n, t) {\n    return (t.getTime() - n.getTime()) / 864e5;\n  }, function (n) {\n    return Math.floor(n.getTime() / 864e5);\n  }), v(function (n) {\n    return n.setUTCHours(0, 0, 0, 0);\n  }, function (n, t) {\n    return n.setUTCDate(n.getUTCDate() + t);\n  }, function (n, t) {\n    return (t.getTime() - n.getTime()) / 864e5;\n  }, function (n) {\n    return Math.floor(n.getTime() / 864e5);\n  })],\n  week: [w, b],\n  sunday: [E, S],\n  monday: [D, C],\n  tuesday: [U, j],\n  wednesday: [O, R],\n  thursday: [H, V],\n  friday: [q, A],\n  saturday: [B, F],\n  month: [N, z],\n  year: [I, P]\n},\n    hn = Object.keys(pn),\n    gn = new RegExp(\"^every\\\\s*(\\\\d+)?\\\\s*(\" + hn.join(\"|\") + \")s?$\", \"i\"),\n    xn = function (n, t) {\n  if (Array.isArray(t)) return t;\n\n  if (\"string\" == typeof t && \"useUTC\" in n) {\n    var r = t.match(gn);\n\n    if (r) {\n      var e = r[1],\n          a = r[2],\n          i = pn[a][n.useUTC ? 1 : 0];\n\n      if (\"day\" === a) {\n        var o,\n            u,\n            c = n.domain(),\n            d = c[0],\n            f = c[1],\n            s = new Date(f);\n        return s.setDate(s.getDate() + 1), null != (o = null == (u = i.every(Number(null != e ? e : 1))) ? void 0 : u.range(d, s)) ? o : [];\n      }\n\n      if (void 0 === e) return n.ticks(i);\n      var l = i.every(Number(e));\n      if (l) return n.ticks(l);\n    }\n\n    throw new Error(\"Invalid tickValues: \" + t);\n  }\n\n  if (\"ticks\" in n) {\n    if (void 0 === t) return n.ticks();\n    if (\"number\" == typeof (m = t) && isFinite(m) && Math.floor(m) === m) return n.ticks(t);\n  }\n\n  var m;\n  return n.domain();\n};\n\nexport { _ as castBandScale, X as castLinearScale, yn as centerScale, on as compareDateValues, an as compareValues, un as computeScale, dn as computeXYScalesForSeries, Z as createBandScale, Q as createDateNormalizer, W as createLinearScale, tn as createLogScale, Y as createPointScale, L as createPrecisionMethod, rn as createSymlogScale, nn as createTimeScale, sn as generateSeriesAxis, fn as generateSeriesXY, en as getOtherAxis, xn as getScaleTicks, J as precisionCutOffs, K as precisionCutOffsByType, ln as stackAxis, G as timePrecisions };","map":{"version":3,"sources":["../src/timeHelpers.ts","../src/linearScale.ts","../src/pointScale.ts","../src/bandScale.ts","../src/timeScale.ts","../src/logScale.ts","../src/symlogScale.ts","../src/compute.ts","../src/ticks.ts"],"names":["timePrecisions","precisionCutOffs","date","setMilliseconds","setSeconds","setMinutes","setHours","setDate","setMonth","precisionCutOffsByType","millisecond","second","slice","minute","hour","day","month","year","createPrecisionMethod","precision","forEach","cutOff","createDateNormalizer","format","useUTC","precisionFn","value","undefined","Date","parseTime","utcParse","timeParse","createLinearScale","min","max","stacked","reverse","clamp","nice","data","size","axis","minValue","minStacked","maxValue","maxStacked","scale","scaleLinear","rangeRound","domain","castLinearScale","typedScale","type","createPointScale","_spec","scalePoint","range","all","createBandScale","round","scaleBand","castBandScale","createTimeScale","normalize","scaleUtc","scaleTime","createLogScale","base","some","v","Error","sign","hasMixedSign","filter","Math","scaleLog","createSymlogScale","constant","scaleSymlog","getOtherAxis","compareValues","a","b","compareDateValues","getTime","computeScale","spec","serie","map","d","getDatumAxisPosition","datum","stackedValue","computeXYScalesForSeries","series","xScaleSpec","yScaleSpec","width","height","nestedSeries","nestSerieData","xy","generateSeriesXY","stackX","stackY","xScale","x","yScale","y","computedSeries","position","generateSeriesAxis","scaleSpec","getValue","setValue","parseFloat","String","values","push","sortBy","uniq","uniqBy","sort","last","stackAxis","otherAxis","compare","isDate","stack","find","stackValue","head","centerScale","bandwidth","offset","timeInterval","step","getDate","start","end","floor","setUTCHours","setUTCDate","getUTCDate","timeByType","timeMillisecond","utcMillisecond","timeSecond","utcSecond","timeMinute","utcMinute","timeHour","utcHour","week","timeWeek","utcWeek","sunday","timeSunday","utcSunday","monday","timeMonday","utcMonday","tuesday","timeTuesday","utcTuesday","wednesday","timeWednesday","utcWednesday","thursday","timeThursday","utcThursday","friday","timeFriday","utcFriday","saturday","timeSaturday","utcSaturday","timeMonth","utcMonth","timeYear","utcYear","timeTypes","Object","keys","timeIntervalRegexp","RegExp","join","isFinite","getScaleTicks","Array","isArray","matches","match","amount","timeType","originalStop","stop","every","Number","ticks","interval"],"mappings":"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","sourcesContent":["import { timeParse, utcParse } from 'd3-time-format'\n\nexport const timePrecisions = [\n    'millisecond',\n    'second',\n    'minute',\n    'hour',\n    'day',\n    'month',\n    'year',\n] as const\n\nexport type TIME_PRECISION = typeof timePrecisions[number]\n\nexport const precisionCutOffs: ((date: Date) => void)[] = [\n    date => date.setMilliseconds(0),\n    date => date.setSeconds(0),\n    date => date.setMinutes(0),\n    date => date.setHours(0),\n    date => date.setDate(1),\n    date => date.setMonth(0),\n]\n\nexport const precisionCutOffsByType: Record<TIME_PRECISION, ((date: Date) => void)[]> = {\n    millisecond: [],\n    second: precisionCutOffs.slice(0, 1),\n    minute: precisionCutOffs.slice(0, 2),\n    hour: precisionCutOffs.slice(0, 3),\n    day: precisionCutOffs.slice(0, 4),\n    month: precisionCutOffs.slice(0, 5),\n    year: precisionCutOffs.slice(0, 6),\n}\n\nexport const createPrecisionMethod = (precision: TIME_PRECISION) => (date: Date) => {\n    precisionCutOffsByType[precision].forEach(cutOff => {\n        cutOff(date)\n    })\n\n    return date\n}\n\nexport const createDateNormalizer = ({\n    format = 'native',\n    precision = 'millisecond',\n    useUTC = true,\n}: {\n    format?: 'native' | string\n    precision?: TIME_PRECISION\n    useUTC?: boolean\n}) => {\n    const precisionFn = createPrecisionMethod(precision)\n\n    return (value: Date | string | undefined) => {\n        if (value === undefined) {\n            return value\n        }\n\n        if (format === 'native' || value instanceof Date) {\n            return precisionFn(value as Date)\n        }\n\n        const parseTime = useUTC ? utcParse(format) : timeParse(format)\n        return precisionFn(parseTime(value as string) as Date)\n    }\n}\n","import { NumberValue, scaleLinear, ScaleLinear as D3ScaleLinear } from 'd3-scale'\nimport { ScaleLinearSpec, ScaleLinear, ComputedSerieAxis, ScaleAxis } from './types'\n\nexport const createLinearScale = <Output extends NumberValue>(\n    {\n        min = 0,\n        max = 'auto',\n        stacked = false,\n        reverse = false,\n        clamp = false,\n        nice = false,\n    }: ScaleLinearSpec,\n    data: ComputedSerieAxis<Output>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    let minValue: NumberValue\n    if (min === 'auto') {\n        minValue = stacked === true ? data.minStacked ?? 0 : data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: NumberValue\n    if (max === 'auto') {\n        maxValue = stacked === true ? data.maxStacked ?? 0 : data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleLinear<number, Output>()\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .domain(reverse ? [maxValue, minValue] : [minValue, maxValue])\n        .clamp(clamp)\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'number') scale.nice(nice)\n\n    return castLinearScale<number, Output>(scale, stacked)\n}\n\nexport const castLinearScale = <Range, Output>(\n    scale: D3ScaleLinear<Range, Output>,\n    stacked = false\n) => {\n    const typedScale = scale as unknown as ScaleLinear<number>\n    typedScale.type = 'linear'\n    typedScale.stacked = stacked\n\n    return typedScale\n}\n","import { scalePoint } from 'd3-scale'\nimport { ComputedSerieAxis, ScalePoint, ScalePointSpec, StringValue } from './types'\n\nexport const createPointScale = <Input extends StringValue>(\n    _spec: ScalePointSpec,\n    data: ComputedSerieAxis<Input>,\n    size: number\n) => {\n    const scale = scalePoint<Input>().range([0, size]).domain(data.all)\n\n    const typedScale = scale as ScalePoint<Input>\n    typedScale.type = 'point'\n\n    return typedScale\n}\n","import { scaleBand, ScaleBand as D3ScaleBand } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleBand, ScaleBandSpec, StringValue, ScaleAxis } from './types'\n\nexport const createBandScale = <Input extends StringValue>(\n    { round = true }: ScaleBandSpec,\n    data: ComputedSerieAxis<Input>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    const scale = scaleBand<Input>()\n        .range(axis === 'x' ? [0, size] : [size, 0])\n        .domain(data.all)\n        .round(round)\n\n    return castBandScale<Input>(scale)\n}\n\nexport const castBandScale = <Input>(scale: D3ScaleBand<Input>) => {\n    const typedScale = scale as ScaleBand<Input>\n    typedScale.type = 'band'\n\n    return typedScale\n}\n","import { NumberValue, scaleTime, scaleUtc } from 'd3-scale'\nimport { createDateNormalizer } from './timeHelpers'\nimport { ComputedSerieAxis, ScaleTime, ScaleTimeSpec } from './types'\n\nexport const createTimeScale = <Input extends Date | NumberValue>(\n    {\n        format = 'native',\n        precision = 'millisecond',\n        min = 'auto',\n        max = 'auto',\n        useUTC = true,\n        nice = false,\n    }: ScaleTimeSpec,\n    data: ComputedSerieAxis<string | Date>,\n    size: number\n) => {\n    const normalize = createDateNormalizer({ format, precision, useUTC })\n\n    let minValue: Date | undefined\n    if (min === 'auto') {\n        minValue = normalize(data.min)\n    } else if (format !== 'native') {\n        minValue = normalize(min)\n    } else {\n        minValue = min as Date\n    }\n\n    let maxValue: Date | undefined\n    if (max === 'auto') {\n        maxValue = normalize(data.max)\n    } else if (format !== 'native') {\n        maxValue = normalize(max)\n    } else {\n        maxValue = max as Date\n    }\n\n    const scale = useUTC ? scaleUtc() : scaleTime()\n\n    scale.range([0, size])\n\n    if (minValue && maxValue) scale.domain([minValue, maxValue])\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'object' || typeof nice === 'number') scale.nice(nice)\n\n    const typedScale = scale as unknown as ScaleTime<Input>\n\n    typedScale.type = 'time'\n    typedScale.useUTC = useUTC\n\n    return typedScale\n}\n","import { scaleLog } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleAxis, ScaleLog, ScaleLogSpec } from './types'\n\nexport const createLogScale = (\n    { base = 10, min = 'auto', max = 'auto' }: ScaleLogSpec,\n    data: ComputedSerieAxis<number>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    const hasZero = data.all.some(v => v === 0)\n    if (hasZero) {\n        throw new Error(`a log scale domain must not include or cross zero`)\n    }\n\n    let sign: number\n    let hasMixedSign = false\n    data.all\n        .filter(v => v != null)\n        .forEach(v => {\n            if (hasMixedSign) return\n            if (sign === undefined) {\n                sign = Math.sign(v)\n            } else if (Math.sign(v) !== sign) {\n                hasMixedSign = true\n            }\n        })\n\n    if (hasMixedSign) {\n        throw new Error(`a log scale domain must be strictly-positive or strictly-negative`)\n    }\n\n    let minValue: number\n    if (min === 'auto') {\n        minValue = data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: number\n    if (max === 'auto') {\n        maxValue = data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleLog<number, number>()\n        .domain([minValue, maxValue])\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .base(base)\n        .nice()\n\n    const typedScale = scale as ScaleLog\n    typedScale.type = 'log'\n\n    return scale\n}\n","import { scaleSymlog } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleAxis, ScaleSymlog, ScaleSymlogSpec } from './types'\n\nexport const createSymlogScale = (\n    { constant = 1, min = 'auto', max = 'auto', reverse = false }: ScaleSymlogSpec,\n    data: ComputedSerieAxis<number>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    let minValue: number\n    if (min === 'auto') {\n        minValue = data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: number\n    if (max === 'auto') {\n        maxValue = data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleSymlog<number, number>()\n        .constant(constant)\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .nice()\n\n    if (reverse === true) scale.domain([maxValue, minValue])\n    else scale.domain([minValue, maxValue])\n\n    const typedScale = scale as ScaleSymlog\n    typedScale.type = 'symlog'\n\n    return typedScale\n}\n","import uniq from 'lodash/uniq'\nimport uniqBy from 'lodash/uniqBy'\nimport sortBy from 'lodash/sortBy'\nimport last from 'lodash/last'\nimport isDate from 'lodash/isDate'\nimport { createDateNormalizer } from './timeHelpers'\nimport { ScaleAxis, ScaleSpec, ScaleValue, SerieAxis, ComputedSerieAxis } from './types'\nimport { createLinearScale } from './linearScale'\nimport { createPointScale } from './pointScale'\nimport { createBandScale } from './bandScale'\nimport { createTimeScale } from './timeScale'\nimport { createLogScale } from './logScale'\nimport { createSymlogScale } from './symlogScale'\n\ntype XY = ReturnType<typeof generateSeriesXY>\n\ntype StackedXY = {\n    [K in keyof XY]: XY[K] & {\n        maxStacked: number\n        minStacked: number\n    }\n}\n\ninterface SerieDatum {\n    x: number | string | Date\n    // only numbers can be stacked\n    xStacked?: number | null\n    y: number | string | Date\n    // only numbers can be stacked\n    yStacked?: number | null\n}\n\ntype Serie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: D[]\n}\n\ntype NestedSerie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: {\n        data: D\n    }[]\n}\n\nexport type ComputedSerie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: {\n        data: D\n        position: {\n            x: number | null\n            y: number | null\n        }\n    }[]\n}\n\ntype Compare = <T>(a: T, b: T) => boolean\n\nexport const getOtherAxis = (axis: ScaleAxis): ScaleAxis => (axis === 'x' ? 'y' : 'x')\n\nexport const compareValues = (a: string | number, b: string | number) => a === b\nexport const compareDateValues = (a: Date, b: Date) => a.getTime() === b.getTime()\n\nexport function computeScale<Input extends ScaleValue>(\n    spec: ScaleSpec,\n    data: ComputedSerieAxis<any>,\n    size: number,\n    axis: ScaleAxis\n) {\n    switch (spec.type) {\n        case 'linear':\n            return createLinearScale(spec, data, size, axis)\n        case 'point':\n            return createPointScale<Input>(spec, data, size)\n        case 'band':\n            return createBandScale<Input>(spec, data, size, axis)\n        case 'time':\n            return createTimeScale(spec, data, size)\n        case 'log':\n            return createLogScale(spec, data, size, axis)\n        case 'symlog':\n            return createSymlogScale(spec, data, size, axis)\n        default:\n            throw new Error('invalid scale spec')\n    }\n}\n\n/**\n * Convert serie data to have the original data stored in a nested prop.\n *\n * We do this in order to avoid conflicts between raw & computed properties.\n * <- { data: { x: 1, y: 3 }[] }\n * -> { data: { data: { x: 1, y: 3 } }[] }\n */\nconst nestSerieData = <S = never, D extends SerieDatum = SerieDatum>(\n    serie: Serie<S, D>\n): NestedSerie<S, D> => ({\n    ...serie,\n    data: serie.data.map(d => ({ data: { ...d } })),\n})\n\nconst getDatumAxisPosition = <D extends SerieDatum = SerieDatum>(\n    datum: { data: D },\n    axis: ScaleAxis,\n    scale: any\n): number | null => {\n    if ('stacked' in scale && scale.stacked) {\n        const stackedValue = datum.data[axis === 'x' ? 'xStacked' : 'yStacked']\n        if (stackedValue === null || stackedValue === undefined) {\n            return null\n        }\n\n        return scale(stackedValue)\n    }\n\n    return scale(datum.data[axis]) ?? null\n}\n\n/**\n * Compute x/y d3 scales from an array of data series, and scale specifications.\n *\n * We use generics as it's not uncommon to have extra properties such as an id\n * added to the series, or extra props on data, in such case, you should override\n * the default types.\n */\nexport const computeXYScalesForSeries = <S = never, D extends SerieDatum = SerieDatum>(\n    series: Serie<S, D>[],\n    xScaleSpec: ScaleSpec,\n    yScaleSpec: ScaleSpec,\n    width: number,\n    height: number\n) => {\n    // first nest series to avoid property conflicts\n    const nestedSeries = series.map(serie => nestSerieData<S, D>(serie))\n\n    // then compute data for each axis: all, min, max values\n    const xy = generateSeriesXY<S, D>(nestedSeries, xScaleSpec, yScaleSpec)\n\n    // stack x values depending on xScale\n    if ('stacked' in xScaleSpec && xScaleSpec.stacked === true) {\n        stackX<S, D>(xy as StackedXY, nestedSeries)\n    }\n\n    // stack y values depending on yScale\n    if ('stacked' in yScaleSpec && yScaleSpec.stacked === true) {\n        stackY<S, D>(xy as StackedXY, nestedSeries)\n    }\n\n    // computes scales\n    const xScale = computeScale<D['x']>(xScaleSpec, xy.x, width, 'x')\n    const yScale = computeScale<D['y']>(yScaleSpec, xy.y, height, 'y')\n\n    // assign position to each datum in every scale\n    const computedSeries: ComputedSerie<S, D>[] = nestedSeries.map(serie => ({\n        ...serie,\n        data: serie.data.map(datum => ({\n            ...datum,\n            position: {\n                x: getDatumAxisPosition(datum, 'x', xScale),\n                y: getDatumAxisPosition(datum, 'y', yScale),\n            },\n        })),\n    }))\n\n    return {\n        ...xy,\n        series: computedSeries,\n        xScale,\n        yScale,\n    }\n}\n\nexport const generateSeriesXY = <S = never, D extends SerieDatum = SerieDatum>(\n    series: NestedSerie<S, D>[],\n    xScaleSpec: ScaleSpec,\n    yScaleSpec: ScaleSpec\n) => ({\n    x: generateSeriesAxis<'x', D['x']>(series, 'x', xScaleSpec),\n    y: generateSeriesAxis<'y', D['y']>(series, 'y', yScaleSpec),\n})\n\n/**\n * Normalize data according to scale type, (time => Date, linear => Number)\n * compute sorted unique values and min/max.\n */\nexport const generateSeriesAxis = <Axis extends ScaleAxis, Value extends ScaleValue>(\n    series: SerieAxis<Axis, Value>,\n    axis: Axis,\n    scaleSpec: ScaleSpec,\n    {\n        getValue = d => d.data[axis],\n        setValue = (d, v) => {\n            d.data[axis] = v\n        },\n    }: {\n        getValue?: (d: { data: Record<Axis, Value | null> }) => Value | null\n        setValue?: (d: { data: Record<Axis, Value | null> }, v: Value) => void\n    } = {}\n) => {\n    if (scaleSpec.type === 'linear') {\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                const value = getValue(d)\n\n                if (value) {\n                    setValue(d, parseFloat(String(value)) as unknown as Value)\n                }\n            })\n        })\n    } else if (scaleSpec.type === 'time' && scaleSpec.format !== 'native') {\n        // `native` means we already have Date instances,\n        // otherwise we have to convert the values to Date.\n        const parseTime = createDateNormalizer(scaleSpec)\n\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                const value = getValue(d)\n\n                if (value) {\n                    setValue(d, parseTime(value as Date) as unknown as Value)\n                }\n            })\n        })\n    }\n\n    const values: unknown[] = []\n\n    series.forEach(serie => {\n        serie.data.forEach(d => {\n            values.push(getValue(d))\n        })\n    })\n\n    switch (scaleSpec.type) {\n        case 'linear': {\n            const all = sortBy(\n                // filer null values to deal with holes in linechart\n                uniq(values as number[]).filter(v => v !== null),\n                v => v\n            )\n\n            return { all, min: Math.min(...all), max: Math.max(...all) }\n        }\n        case 'time': {\n            const all = uniqBy(values as Date[], v => v.getTime())\n                .slice(0)\n                .sort((a, b) => b.getTime() - a.getTime())\n                .reverse()\n\n            return { all, min: all[0], max: last(all) }\n        }\n        default: {\n            const all = uniq(values)\n\n            return { all, min: all[0], max: last(all) }\n        }\n    }\n}\n\nexport const stackAxis = <S = never, D extends SerieDatum = SerieDatum>(\n    axis: ScaleAxis,\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => {\n    const otherAxis = getOtherAxis(axis)\n    const all: number[] = []\n\n    xy[otherAxis].all.forEach(v => {\n        const compare = (isDate(v) ? compareDateValues : compareValues) as Compare\n        const stack: Array<number | null> = []\n\n        series.forEach(serie => {\n            const datum = serie.data.find(d => compare(d.data[otherAxis], v))\n            let value = null\n            let stackValue = null\n\n            if (datum !== undefined) {\n                // stacked values only support numbers\n                value = datum.data[axis] as number\n                if (value !== null) {\n                    const head = last(stack)\n                    if (head === undefined) {\n                        stackValue = value\n                    } else if (head !== null) {\n                        stackValue = head + value\n                    }\n                }\n\n                datum.data[axis === 'x' ? 'xStacked' : 'yStacked'] = stackValue\n            }\n\n            stack.push(stackValue)\n\n            if (stackValue !== null) {\n                all.push(stackValue)\n            }\n        })\n    })\n\n    xy[axis].minStacked = Math.min(...all)\n    xy[axis].maxStacked = Math.max(...all)\n}\n\nconst stackX = <S = never, D extends SerieDatum = SerieDatum>(\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => stackAxis<S, D>('x', xy, series)\n\nconst stackY = <S = never, D extends SerieDatum = SerieDatum>(\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => stackAxis<S, D>('y', xy, series)\n","import {\n    CountableTimeInterval,\n    timeMillisecond,\n    utcMillisecond,\n    timeSecond,\n    utcSecond,\n    timeMinute,\n    utcMinute,\n    timeHour,\n    utcHour,\n    timeWeek,\n    utcWeek,\n    timeSunday,\n    utcSunday,\n    timeMonday,\n    utcMonday,\n    timeTuesday,\n    utcTuesday,\n    timeWednesday,\n    utcWednesday,\n    timeThursday,\n    utcThursday,\n    timeFriday,\n    utcFriday,\n    timeSaturday,\n    utcSaturday,\n    timeMonth,\n    utcMonth,\n    timeYear,\n    utcYear,\n    timeInterval,\n} from 'd3-time'\nimport { ScaleValue, TicksSpec, AnyScale, ScaleWithBandwidth } from './types'\n\nexport const centerScale = <Value>(scale: ScaleWithBandwidth) => {\n    const bandwidth = scale.bandwidth()\n\n    if (bandwidth === 0) return scale\n\n    let offset = bandwidth / 2\n    if (scale.round()) {\n        offset = Math.round(offset)\n    }\n\n    return <T extends Value>(d: T) => (scale(d) ?? 0) + offset\n}\n\nconst timeDay = timeInterval(\n    date => date.setHours(0, 0, 0, 0),\n    (date, step) => date.setDate(date.getDate() + step),\n    (start, end) => (end.getTime() - start.getTime()) / 864e5,\n    date => Math.floor(date.getTime() / 864e5)\n)\n\nconst utcDay = timeInterval(\n    date => date.setUTCHours(0, 0, 0, 0),\n    (date, step) => date.setUTCDate(date.getUTCDate() + step),\n    (start, end) => (end.getTime() - start.getTime()) / 864e5,\n    date => Math.floor(date.getTime() / 864e5)\n)\n\nconst timeByType: Record<string, [CountableTimeInterval, CountableTimeInterval]> = {\n    millisecond: [timeMillisecond, utcMillisecond],\n    second: [timeSecond, utcSecond],\n    minute: [timeMinute, utcMinute],\n    hour: [timeHour, utcHour],\n    day: [timeDay, utcDay],\n    week: [timeWeek, utcWeek],\n    sunday: [timeSunday, utcSunday],\n    monday: [timeMonday, utcMonday],\n    tuesday: [timeTuesday, utcTuesday],\n    wednesday: [timeWednesday, utcWednesday],\n    thursday: [timeThursday, utcThursday],\n    friday: [timeFriday, utcFriday],\n    saturday: [timeSaturday, utcSaturday],\n    month: [timeMonth, utcMonth],\n    year: [timeYear, utcYear],\n}\n\nconst timeTypes = Object.keys(timeByType)\nconst timeIntervalRegexp = new RegExp(`^every\\\\s*(\\\\d+)?\\\\s*(${timeTypes.join('|')})s?$`, 'i')\n\nconst isInteger = (value: unknown): value is number =>\n    typeof value === 'number' && isFinite(value) && Math.floor(value) === value\n\nexport const getScaleTicks = <Value extends ScaleValue>(\n    scale: AnyScale,\n    spec?: TicksSpec<Value>\n) => {\n    // specific values\n    if (Array.isArray(spec)) {\n        return spec\n    }\n\n    if (typeof spec === 'string' && 'useUTC' in scale) {\n        // time interval\n        const matches = spec.match(timeIntervalRegexp)\n\n        if (matches) {\n            const [, amount, type] = matches\n            // UTC is used as it's more predictable\n            // however local time could be used too\n            // let's see how it fits users' requirements\n            const timeType = timeByType[type][scale.useUTC ? 1 : 0]\n\n            if (type === 'day') {\n                const [start, originalStop] = scale.domain()\n                const stop = new Date(originalStop)\n\n                // Set range to include last day in the domain since `interval.range` function is exclusive stop\n                stop.setDate(stop.getDate() + 1)\n\n                return timeType.every(Number(amount ?? 1))?.range(start, stop) ?? []\n            }\n\n            if (amount === undefined) {\n                return scale.ticks(timeType)\n            }\n\n            const interval = timeType.every(Number(amount))\n\n            if (interval) {\n                return scale.ticks(interval)\n            }\n        }\n\n        throw new Error(`Invalid tickValues: ${spec}`)\n    }\n\n    // continuous scales\n    if ('ticks' in scale) {\n        // default behaviour\n        if (spec === undefined) {\n            return scale.ticks()\n        }\n\n        // specific tick count\n        if (isInteger(spec)) {\n            return scale.ticks(spec)\n        }\n    }\n\n    // non linear scale default\n    return scale.domain()\n}\n"]},"metadata":{},"sourceType":"module"}